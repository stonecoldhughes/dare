#For autotune mode, stdin arguments must be in the format:
#num_args kernel_fraction 10:100 tile_size 128 (for example)
#use_stdin must be indicated in the config file.
#all arguments that use stdin must say "stdin" as their text field
#in the config file
import xml.etree.ElementTree as xml
import subprocess
from pathlib import Path
import argparse
import sys
import re

#Standard 4 space tab
four_space = '    '

autogen_warning = \
'''/* 
Warning! This file is autogenerated by autogen.py. Modifications will be 
overwritten
*/
'''

autogen_types_h_includes = \
'''#include "mkl_cblas.h"
#include "mkl_lapacke.h"
#include "plasma.h"

using namespace std;

'''

autogen_cpp_part_0 = \
'''#include "dare_base.h"

using namespace std;

/*This will obtain function pointers to hooks in the PLASMA library*/
dare_base::dare_base()
{{
    void (*fptr)();
    
    /* OpenMP returns 1 if this is called outside a parallel region */
    #pragma omp parallel
    {{
        num_threads = omp_get_max_threads();
    }}

    /* Set the default output flag */
    default_output = {default_output};

    /* Set the output file name */
    output_file_name = "{output_file_name}";

    /* Obtain a handle to the core_blas library */
    void *core_blas_file = dlopen(
                                 "{prefix}libcoreblas.so", 
                                 RTLD_LAZY
                                 );

    if(core_blas_file == NULL) {{printf("core_blas_file null\\n"); exit(0);}}
    
    /* Obtain a handle to the plasma library */
    void *plasma_file = dlopen(
                        "{prefix}libplasma.so",
                        RTLD_LAZY
                        );

    if(plasma_file == NULL) {{printf("plasma_file null\\n"); exit(0);}}

    /* hook plasma_init() */
    fptr = (void (*)())dlsym(plasma_file, "plasma_init");
    if(fptr == NULL) {{printf("plasma_init() hook NULL\\n"); exit(0);}}
    plasma_init_ptr = fptr;
'''

autogen_cpp_part_1 = \
'''
    /* fetch symbol for {name} */
    fptr = (void (*)())dlsym(core_blas_file, "{name}");
    
    if(fptr == NULL) {{printf("{name}() hook NULL\\n"); exit(0);}}
    
    core[{name_uppercase}] = fptr;

'''

autogen_cpp_part_2 = \
'''
    /* allocate kernel_vec */
    kernel_vec = new vector<class kernel_node>*[num_threads];

    for(int i = 0; i < num_threads; ++i)
    {
        kernel_vec[i] = new vector<class kernel_node>();
    }

    /* allocate add_node */
    add_node = new int[num_threads];

    for(int i = 0; i < num_threads; ++i)
    {
        add_node[i] = 1;
    }

    return;
}

dare_base::~dare_base()
{
    /* dump data to a file */
    /* these functions also clear the vector in case file is written to
    multiple times*/

    if(default_output)
    {
        dump_data();
    }

    /* free kernel_vec */
    for(int i = 0; i < num_threads; ++i)
    {
        kernel_vec[i]->clear();
        delete kernel_vec[i];
    }

    delete[] kernel_vec;

    /* free add_node */
    delete[] add_node;

    return;
}
'''

parse_stdin_string = \
'''
/* Obtains variable number of arguments from stdin */
void parse_stdin()
{
    int num_args;

    string input;

    string tag;

    string ratio;

    stringstream ss;

    getline(cin, input);

    ss.str(input);

    ss >> num_args;

    for(int i = 0; i < num_args; ++i)
    {
        ss >> tag;

        if(tag == "tile_size")
        {
            ss >> autotune.tile_size;
        }

        else if(tag == "execution_ratio")
        {
            ss >> ratio;

            int colon = ratio.find(':');

            autotune.numerator = atoi(ratio.substr(0, colon).c_str());

            autotune.denominator = atoi(ratio.substr(colon + 1).c_str());
        }

        else
        {
            printf("unrecognized stdin data tag\\n");

            exit(0);
        }
    }

    return;
}

'''

hooks_cpp_trace_template = \
'''{h_files}
{externs}
extern class Profile profile;

using namespace std;
{hooks}
'''

#a series of these concatenated replace the 'hooks' argument
#in the hooks_cpp_trace_template
trace_hook_template = \
'''

{definition}{{
{invocation}
}}
'''

case_template = \
'''
        {fake_data_type} *ptr = 
        (class {fake_data_type}*)((*autotune.data[thread_num])[{cname}]);

        if(ptr->tile_times_empty())
        {{
            {run}
            ptr->append_time(profile.last_kernel_time());
        }}

        else if(ptr->clip_empty())
        {{
            {busy_wait}
        }}

        else
        {{
            if(++autotune.iterations[thread_num][{cname}] == 
               autotune.autotune_counter)
            {{
                autotune.iterations[thread_num][{cname}] = -1;

                {run}
                ptr->append_time(profile.last_kernel_time());
            }}

            else
            {{
                {busy_wait}
            }}
        }}
'''

data_dep_template = \
'''
{definition}{{
    int ret_val;

    int random_n = rand() % autotune.denominator;

    if(random_n < autotune.numerator)
    {{
        int thread_num = omp_get_thread_num();
{cases}
    }}

    return PlasmaSuccess;
}}
'''

autotune_void_hook_template = \
'''
{definition}{{
    int random_n = rand() % autotune.denominator + 1;

    if(random_n <= autotune.numerator)
    {{
{invocation}
    }}

    return;
}}
'''

autotune_not_void_hook_template = \
'''
{definition}{{
    int ret_val;
    
    int random_n = rand() % autotune.denominator + 1;

    if(random_n <= autotune.numerator)
    {{
{invocation}
    }}

    return ret_val;
}}
'''

cmake_lists_template = \
'''set(CMAKE_CXX_COMPILER {cpp})
set(CMAKE_C_COMPILER {c})
        
{include_dirs}

project(optimize C CXX)

{add_library}

{target_link_libraries}
'''

cmake_target_link_libraries_template = \
'''{line_0}
{spaces}profile_lib
{spaces}{plasma_dir}/lib/libcoreblas.so
{spaces}{plasma_dir}/lib/libplasma.so
{spaces}-fopenmp
{spaces})
'''
cmake_include_dirs_template = \
'''{line_0}
{dir_list}
{spaces})
'''

cmake_add_library_template = \
'''{line_0}
{spaces}profile_lib SHARED
{spaces}hooks.cpp
{spaces}autogen.cpp
{spaces}profile.cpp
{spaces}dare_base.cpp
{extra_files}
{spaces})
'''

hooks_cpp_autotune_template = \
'''{warning}
#include "profile.h"
#include "autotune.h"
#include <sstream>
#include <iostream>
#include <string>

extern class Profile profile;

extern class Autotune autotune;

using namespace std;
{parse_stdin}
extern "C" int plasma_init()
{{
    int ret_val;

    int tile_size;
    
    ret_val = ((plasma_init_hook_type)profile.plasma_init_ptr)();
    {parse_stdin_call}
    plasma_set(PlasmaNb, autotune.tile_size);

    plasma_get(PlasmaNb, &tile_size);

    {fake_init}

    return ret_val;
}}

{hooks}
'''

#Classes
class rgx_obj_class:
    
    def __init__(self):
        
        self.file_regex = re.compile(r'core_blas_\w\.h')
        
        self.core_regex = re.compile(
        r'\s*(\w*\n?)\s+(core_(?!omp)\w+)\s*\(([^;]*)\)')
        
        self.arg_regex = re.compile(r'(.*) \**(.*)')

class wrap_class:
    
    def __init__(self, root, tag_string):
        
        tag = root.find(tag_string)

        if(tag == None):
            
            print('{tag} not found. Exiting'.format(tag = tag_string))

            sys.exit()

        #Get the function's name
        name_tag = tag.find('name')

        if(name_tag == None):
            
            print('name tag not found under {tag}. Exiting'.format(tag = tag_string))

            sys.exit()
        
        self.name = name_tag.text.strip()

        #Get the function's declaration
        decl_tag = tag.find('declaration')

        if(decl_tag == None):
            
            print('declaration tag not found under {tag} Exiting'.format(tag = tag_string))

            sys.exit()

        self.declaration = decl_tag.text.strip()

        #Get the function's file extension
        filex_tag = tag.find('file_extension')

        if(filex_tag == None):
            
            print('file_extention tag not found under {tag}. Exiting' \
                  .format(tag = tag_string))

        self.file_extension = filex_tag.text.strip()
        
        #Find the function's args
        self.arg_list = self.list_args(tag, root)

    #return a string of the below function call specialized for a particular kernel
    def wrap_string(self, core_kernel_enum, use_default):

        if(use_default == 1):

            call = 'profile.track_kernel((unsigned long){name}, omp_get_wtime());'\
                   .format(name = core_kernel_enum)

        else:
            
            call = self.name + '('

            arg_string = ''

            if(self.arg_list):

                for arg_map in self.arg_list[:-1]:
                    
                    if(core_kernel_enum in arg_map):
                    
                        arg_string = arg_map[core_kernel_enum]

                    else:
                        
                        arg_string = arg_map['default']

                    call += arg_string + ', '

                arg_map = self.arg_list[-1]

                if(core_kernel_enum in arg_map):
                
                    arg_string = arg_map[core_kernel_enum]

                else:
                    
                    arg_string = arg_map['default']

            call += arg_string + ');'

        return call

    def list_args(self, tag, root):

        arg_list = []

        args_tag = tag.find('args')

        if(args_tag != None):
            
            arg_tag_list = args_tag.findall('arg')

            if(not arg_tag_list):

                print('no arg tags found. Exiting')

                sys.exit()
            
            for arg_tag in arg_tag_list:
                
                arg_map = {}
                
                if(arg_tag.get('configurable') == 'True'):

                    #Find the list of choices for this arg and create a dict out of it
                    arg_set = root.find(arg_tag.text.strip())

                    if(arg_set != None):

                        pairs = arg_set.findall('pair')

                        for pair in pairs:
                         
                            val_str = pair.find('value').text.strip()
                            
                            arg_map[pair.find('key').text.strip()] = val_str

                else:
            
                    arg_map['default'] = arg_tag.text.strip()

                arg_list.append(arg_map)

        return arg_list

    def print_data(self):
        
        print(
        '''
        name = {name}
        declaration = {decl}
        file_extension = {filex}
        '''.format(
                  name = self.name, \
                  decl = self.declaration, \
                  filex = self.file_extension \
                  ))

        for arg_map in self.arg_list:
        
            print('args: {arg_map}'.format(arg_map = arg_map))
        
        return

class autotune_config_class:
    
    def __init__(self, root, data_dep_functions, core_kernel_list):

        self.init_config_variables(root)
        
        self.stdin_block = self.generate_stdin_block()

        self.fake_data_block = self.generate_fake_data_block(data_dep_functions)

    def print_data(self):
        
        print(self.stdin_block)

        print(self.fake_data_block)

        return
        
    def init_config_variables(self, root):
        
        #Get flag for whether stdin is source for params or not
        stdin_tag = root.find('use_stdin')

        if(stdin_tag == None):
            
            print('use_stdin tag must be present')

            sys.exit()
        
        self.stdin_flag = int(stdin_tag.text.strip())
    
        #Get tile size
        tile_size_tag = root.find('tile_size')

        if(tile_size_tag == None):
            
            print('\"tile_size\" tag not found. Exiting')

            sys.exit()
        
        self.tile_size = tile_size_tag.text.strip()

        self.init_ratio(root)

        #Get clip size
        clip_size_tag = root.find('clip_size')

        if(clip_size_tag == None):
            
            print('clip_size not present. Exiting')

            sys.exit()

        self.clip_size = clip_size_tag.text.strip()

        #Get max window size
        max_window_size_tag = root.find('max_window_size')

        if(max_window_size_tag == None):

            print('max_window_size not present. Exiting')

            sys.exit()

        self.max_window_size = max_window_size_tag.text.strip()
    
        #Get autotune counter
        autotune_counter_tag = root.find('autotune_counter')

        if(autotune_counter_tag == None):
            
            print('autotune_counter_tag not found. Exiting')

            sys.exit()

        self.autotune_counter = int(autotune_counter_tag.text.strip())

        return

    #Gets the fraction of functions that should run
    def init_ratio(self, root):
        
        ratio_tag = root.find('execution_ratio')

        if(ratio_tag == None):
            
            print('\"execution_ratio\" tag not found. Exiting')

            sys.exit()
        
        ratio_string = ratio_tag.text.strip()

        self.ratio = []

        if(ratio_string != 'stdin'):
            
            ratio_string_list = ratio_string.split(':')


            self.ratio.append(int(ratio_string_list[0]))
            
            self.ratio.append(int(ratio_string_list[1]))

        return

    def generate_stdin_block(self):
        
        string = ''

        if(self.stdin_flag):
            string += \
    '''
    /* get arguments from stdin */
    parse_stdin();

    '''
    
        if(self.tile_size != 'stdin'):
            
            string += 'autotune.tile_size = {tile_size};\n'\
                      .format(tile_size = self.tile_size)

        if(self.ratio):

            string += \
    '''autotune.numerator = {numerator};

    autotune.denominator = {denominator};
    '''.format(numerator = self.ratio[0],\
               denominator = self.ratio[1])

        return string
    
    def generate_fake_data_block(self, data_dep_functions):
        
        string = \
    '''
    autotune.clip_size = {clip_size};

    autotune.max_window_size = {max_window_size};

    autotune.autotune_counter = {autotune_counter};
        
    /* Populate each map with the kernels specified in the config file */
    for(int i = 0; i < autotune.num_threads; ++i)
    {{
        autotune.iterations[i] = new unsigned int[TABLE_SIZE];

        for(int j = 0; j < TABLE_SIZE; ++j)
        {{
            /* Another random run will be added before clip times is accessed */
            autotune.iterations[i][j] = autotune.autotune_counter - 1;
        }}

        {init_block}
    }}
    '''.format(clip_size = self.clip_size,\
                   max_window_size = self.max_window_size,\
                   autotune_counter = self.autotune_counter,\
                   init_block = self.fake_data_classes(data_dep_functions))

        return string

    def fake_data_classes(self, data_dep_functions):
        
        string = ''

        for f in data_dep_functions:
            
            if(f == 'core_dpotrf'):
                
                print('creating fake_data for core_dpotrf...')
                
                string += \
        '''
        autotune.data[i]->emplace(
                                 CORE_DPOTRF,
                                 new class fake_dpotrf_data(
                                                           autotune.clip_size,
                                                           autotune.tile_size,
                                                           autotune.max_window_size
                                                           )
                                 );
        '''
                
        return string
    
    def wrap_string(self, name):
        
        return 'profile.track_kernel((unsigned long){name}, omp_get_wtime());'\
               .format(name = name)

    def wrapped_invocation_as_list(self, c):
        
        lines = []

        wrapper = self.wrap_string(c.name.upper())

        lines.append(wrapper + '\n\n')

        tmp = c.function_call_as_list
        
        tmp.append('\n')
        
        lines.extend(tmp)
        
        lines.append(wrapper)

        return lines

class trace_config_class:
    
    def __init__(self, root):
        
        #Create wrappers
        self.wrap_above = wrap_class(root, 'wrap_above_func')

        self.wrap_below = wrap_class(root, 'wrap_below_func')

        self.use_default = get_use_default(root)

        self.h_files = self.gen_h_files()
        
        self.extern_c = self.gen_extern_c()

    #wrap a single function invocation as a list in proper wrappers
    #with proper return value
    def wrapped_invocation_as_list(self, c):
        
        lines = []

        if(c.rtype != 'void'):
            
            lines.append('{rtype} ret_val;\n\n'.format(rtype = c.rtype))

        lines.append(self.wrap_above.wrap_string(c.name.upper(),\
                                                 self.use_default) + '\n\n')

        tmp = c.function_call_as_list
        
        tmp.append('\n')
        
        lines.extend(tmp)
        
        lines.append(self.wrap_below.wrap_string(c.name.upper(),\
                                                 self.use_default) + '\n\n')

        if(c.rtype != 'void'):

            lines.append('return ret_val;')

        else:
            
            lines.append('return;')

        return lines

    def gen_extern_c(self):
        
        externs = ''

        if(self.use_default == 0):
        
            externs = '\n'
            
            if(self.wrap_above.file_extension == '.c'):
                
                externs +=  'extern "C" {decl};\n'.format(decl = self.wrap_above\
                                                                    .declaration)

            if(self.wrap_below.file_extension == '.c'):

                externs +=  'extern "C" {decl};\n'.format(decl = self.wrap_below\
                                                                .declaration)

        return externs

    def gen_h_files(self):
        
        h_files = '''#include "profile.h"'''
        
        if(self.use_default == 0):

            #Obtain the list of header files
            trace_h = root.find('trace_h').findall('h')

            for h in trace_h:
                
                h_files += '\n#include "{h_file}"'.format(h_file = h.text.strip())

        return h_files

    def print_wrappers(self):

        print('above wrapper:')

        self.wrap_above.print_data()

        print('below wrapper:')

        self.wrap_below.print_data()

class core_class:
    
    def __init__(self, rtype, name, args, data_dep_functions, mode_str):
        
        self.rtype = rtype
        
        self.name = name
        
        #list of arguments with their data types
        typed_arg_list = self.extract_typed_args(args)

        #list or arguments without data types
        untyped_arg_list = self.extract_untyped_args(typed_arg_list)
        
        #typedef definition portion before the arguments
        typedef_string = self.generate_typedef_string()

        #function definition portion before the arguments
        definition_string = self.generate_definition_string()
        
        #function call portion before the arguments
        function_call_str = self.generate_function_call_string(mode_str)

        #express the typedef as a list
        typedef_as_list = self.listify_function(typed_arg_list,\
                                                typedef_string)

        #express the typedef as a string
        self.typedef = self.space_out(typedef_as_list, '')

        #express the function definition as a list
        function_def_as_list = self.listify_function(typed_arg_list,\
                                                     definition_string,\
                                                     None,\
                                                     False)

        #express the function definition as a string
        self.function_def = self.space_out(function_def_as_list, '')

        #express the function call as a list. Will not be expressed as a string
        #because it is not known how much space it will need to be tabbed over by
        self.function_call_as_list = self.listify_function(untyped_arg_list,\
                                                           function_call_str,\
                                                           data_dep_functions)

    def generate_typedef_string(self):
        
        string = 'typedef {rtype} (*{name}_hook_type)(\n'\
                 .format(rtype = self.rtype,\
                         name = self.name)
        return string

    def generate_function_call_string(self, mode_str):

        if(mode_str == 'trace'):
            
            if(self.rtype == 'void'):

                call = '(({name}_hook_type)profile.core[{upper}])(\n'\
                .format(name = self.name, upper = self.name.upper())

            else:

                call = 'ret_val = (({name}_hook_type)profile.core[{upper}])(\n'\
                .format(name = self.name, upper = self.name.upper())

        elif(mode_str == 'autotune'):

            if(self.rtype == 'void'):
                
                call = '(({name}_hook_type)autotune.core[{upper}])(\n'\
                .format(name = self.name, upper = self.name.upper())

            else:
                
                call = 'ret_val = (({name}_hook_type)autotune.core[{upper}])(\n'\
                .format(name = self.name, upper = self.name.upper())

        return call

    def generate_definition_string(self):
        
        string = 'extern "C" {rtype} {name}(\n'.format(rtype = self.rtype,\
                                                       name = self.name)

        return string

    #concatenate lines and spaces into a string
    def space_out(self, lines, spaces):
        
        full_string = ''''''

        for line in lines:

            string = spaces + line

            full_string += string

        return full_string

    def insert_fake_data(self, arg_list):

        if(self.name == 'core_dpotrf'):

           n_pos = 1

           A_pos = 2

           lda_pos = 3

           arg_list[n_pos] = 'ptr->get_tile_size()'

           arg_list[A_pos] = 'ptr->tile()'

           arg_list[lda_pos] = arg_list[n_pos]

        else:
            
            print('unrecognized kernel listed as needing fake data. Exiting')

            sys.exit()
        
        return

    #create each line of the function as a list element properly spaced
    #semicolon argument indicates whether the terminating paren should be
    #followed by a semicolon
    def listify_function(self, arg_list,\
                         call_string,\
                         data_dep_functions = None,\
                         semicolon = True):
        
        f = []

        spaces = (len(call_string) - 2) * ' '

        f.append(call_string)

        if(data_dep_functions != None):

            if(self.name in data_dep_functions):
                
                #modify the arg list according to which name it is
                self.insert_fake_data(arg_list)

        #Does not include final arg
        for arg in arg_list[:-1]:
            
            f.append(spaces + arg + ',\n')

        #final arg is not followed by a comma
        f.append(spaces + arg_list[-1] + '\n')

        #closing paren
        if(semicolon):
            
            close = ');\n'

        else:
            
            close = ')\n'

        f.append(spaces + close)

        return f
    
    def print_lists(self):

        print('{cname}:'.format(cname = self.name))

        print('full typedef:')

        print(self.typedef)

        print('full function call:')

        function_call = self.space_out(self.function_call_as_list, '    ')

        print(function_call)
        
        print('full function definition:')

        print(self.function_def)

        return

    #return a list of args with their data-types still attached
    def extract_untyped_args(self, arg_list):
        
        stripped = []

        for arg in arg_list:

            match = rgx_obj.arg_regex.fullmatch(arg)

            if(match == None):
                
                print('unrecognized pattern in function arguments. Exiting.')

                sys.exit()
            
            stripped.append(match.group(2).strip())

        return stripped
            

    #return a list of args without data types or dereference operators attached
    def extract_typed_args(self, args):

        raw_arg_list = args.split(',') 

        arg_list = []

        for arg in raw_arg_list:
            
            arg_list.append(arg.strip())

        return arg_list

#Methods

#Captain! Fix this
def fake_data_run(c):
    
    string = ''

    if(c.name == 'core_dpotrf'):
        
        string = \
        '''
            profile.track_kernel({cname}, omp_get_wtime());
            int ret_val = core_dpotrf(
                    PlasmaLower,
                    ptr->get_tile_size(),
                    ptr->tile(),
                    ptr->get_tile_size()
                    );

            profile.track_kernel({cname}, omp_get_wtime());
            ptr->append_time(profile.last_kernel_time());
        '''.format(cname = c.name.upper())

    else:

        print('instructions to run \"{cname}\" with fake_data not found')

        print('check \"fake_data_run\" in autogen.py. Exiting')

        sys.exit()

    return string

def fake_data_busy_wait(c):

    string = ''
    
    if(c.name == 'core_dpotrf'):
        
        string = \
        '''
            double t = ptr->tile_time();
            profile.track_kernel({cname}, omp_get_wtime());
            ptr->busy_wait(t);
            profile.track_kernel({cname}, omp_get_wtime());
        '''.format(cname = c.name.upper())

    else:

        error = \
        '''
        instructions to run \"{cname}\" with fake_data not found.
        check \"fake_data_busy_wait\" in autogen.py. Exiting
        '''
        print(error)

        sys.exit()

    return string

def write_lookup_tables(autogen_types_h, core_kernel_list):

    enum_string = ''

    kernel_string = ''

    i = 0

    for c in core_kernel_list:
        
        enum_string += '{space}{name} = {i},\n'.format(space = four_space, \
                                                       name = c.name.upper(), \
                                                       i = i)

        kernel_string += '{space}\"{name}\",\n'.format(space = four_space, \
                                                       name = c.name)
        
        i += 1
    
    autogen_types_h.write(
'''enum functions_enum
{{
{enum_string}
{four_space}TABLE_SIZE
}};

const string kernel_table[] = 
{{
{kernel_string}
}};

'''.format(four_space = four_space, \
           enum_string = enum_string, \
           kernel_string = kernel_string))
    
    return

#Write typedef function pointers for core_blas routines
def write_typedefs(autogen_types_h, core_kernel_list):
    
    typedef_string = ''

    for c in core_kernel_list:

        typedef_string += c.typedef + '\n'

    autogen_types_h.write( \
'''
{typedef_string}

typedef int (*plasma_init_hook_type)();
'''.format(typedef_string = typedef_string))
        
    return

#Generate autogen_types.h
def write_autogen_types_h(autogen_types_h, core_kernel_list):

    #autogen warning
    autogen_types_h.write(autogen_warning)

    #includes
    autogen_types_h.write(autogen_types_h_includes)
   
    write_lookup_tables(autogen_types_h, core_kernel_list)

    write_typedefs(autogen_types_h, core_kernel_list)

    return

def dump_file(string):
    
    f = open(string, 'r')
    
    file_list = list(f)
    
    f.close()
    
    file_string = ''
    
    for line in file_list:
        
        file_string = file_string + ' ' + line.strip()
    
    return file_string

def parse_hdr(hdr_file_string, mode_str, data_dep_functions):
    
    core_functions_map = {}

    matches = rgx_obj.core_regex.finditer(hdr_file_string)

    for m in matches:

        if(m.group(2) not in core_functions_map):
            
            core_functions_map[m.group(2)] = core_class(m.group(1),\
                                                        m.group(2),\
                                                        m.group(3),\
                                                        data_dep_functions,\
                                                        mode_str)

    #Check the data_dep_functions list
    for d in data_dep_functions:
    
        if(d not in core_functions_map):
            
            print('\"{core_name}\" function not found in core_blas. Exiting'\
                  .format(core_name = d))

            sys.exit()

    return core_functions_map

#Creates a dictionary of function names and their associated fake_data subclass
def find_data_dep_functions(root):
    
    tag = root.find('data_dep_functions')
    
    if(tag == None):
        
        return ''

    more_tags = tag.findall('function')
    
    data_dep_functions = {}

    #Obtain the list of items fake_data will be needed for
    for k in more_tags:
        
        k_text = k.text.strip()

        if(k_text == 'core_dpotrf'):
            
            data_dep_functions['core_dpotrf'] = 'fake_dpotrf_data'

        else:
            
            error = \
            '''
            no instructions for data dependent function \"{name}\".
            Exiting.'''.format(name = k_text)

            print(error)

            sys.exit()
            
    return data_dep_functions

def get_use_default(root):
    
    #Determine whether or not to use default settings
    use_default_tag = root.find('use_default')
    
    if(use_default_tag == None):
        
        print('use default tag not found: exiting')
        
        sys.exit()
    
    use_default = int(use_default_tag.text.strip())
    
    if(use_default != 1 and use_default != 0):
        
        print('use default tag must be either 1 or 0: exiting')
        
        sys.exit()

    return use_default

def write_autogen_cpp(autogen_cpp, core_kernel_list, root):

    use_default = get_use_default(root)

    #Get the output file name
    ofn_tag = root.find('output_file_name')

    #If no output file name tag is found, use the default
    if(ofn_tag == None):
        
        ofn = 'output.txt'

    else:
        
        ofn = ofn_tag.text.strip()
    
    #Obtain the top-level directory for PLASMA
    plasma_dir = root.find('plasma_dir').text.strip()

    part_0_string = autogen_cpp_part_0.format(prefix = plasma_dir + '/lib/',\
                                              default_output = use_default,\
                                              output_file_name = ofn)

    part_1_string = ''

    for c in core_kernel_list:

        part_1_string += autogen_cpp_part_1.format(name = c.name,
                                                   name_uppercase = c.name.upper())

    autogen_cpp.write(part_0_string + part_1_string + autogen_cpp_part_2)

    return

def write_hooks_cpp(hooks_cpp, core_kernel_list, root, mode_str, data_dep_functions):

    if(mode_str == 'trace'):
        
        print('trace mode')

        #extract trace configuration information
        config = trace_config_class(root)
        
        hook_string = ''

        for c in core_kernel_list:
            
            #Obtain the function invocation lines as a list
            wrapped_call_list = config.wrapped_invocation_as_list(c)

            #Convert the invocation lines to a string
            invocation = c.space_out(wrapped_call_list, '    ')

            hook_string += trace_hook_template.format(definition = c.function_def,\
                                                      invocation = invocation)

        string = hooks_cpp_trace_template.format(h_files = config.h_files,\
                                           externs = config.extern_c,\
                                           hooks = hook_string)

        hooks_cpp.write(string)

    else:

        print('autotune mode')

        autotune_config = autotune_config_class(root,\
                                                data_dep_functions,\
                                                core_kernel_list)

        hook_string = ''

        for c in core_kernel_list:
            
            if(c.name in data_dep_functions):
                
                print('{name} requires fake_data'.format(name = c.name))
                
                #Create the invocation
                wrapped_call_list = autotune_config.wrapped_invocation_as_list(c)

                invocation = c.space_out(wrapped_call_list, '        ')

                #Captain! Fill all this in!
                cases = case_template\
                        .format(fake_data_type = data_dep_functions[c.name],\
                                cname = c.name.upper(),\
                                run = invocation,\
                                busy_wait = fake_data_busy_wait(c))

                hook_string += data_dep_template\
                               .format(definition = c.function_def,\
                                       cases = cases)

            else:

                wrapped_call_list = autotune_config.wrapped_invocation_as_list(c)

                invocation = c.space_out(wrapped_call_list, '        ')

                if(c.rtype != 'void'):
                    
                    hook_string += autotune_not_void_hook_template\
                                   .format(definition = c.function_def,\
                                           invocation = invocation)

                else:
                    
                    hook_string += autotune_void_hook_template\
                                   .format(definition = c.function_def,\
                                           invocation = invocation)

        string = hooks_cpp_autotune_template\
                 .format(parse_stdin = parse_stdin_string,\
                         parse_stdin_call = autotune_config.stdin_block,\
                         fake_init = autotune_config.fake_data_block,\
                         warning = autogen_warning,\
                         hooks = hook_string)

        hooks_cpp.write(string)

    return

def add_libraries(root, mode_str):

    string = ''

    line_0 = 'add_library('

    spaces = (len(line_0) - 1) * ' '

    use_default = get_use_default(root)

    extra_files = ''
    
    if(mode_str == 'trace' and use_default == 0):
        
        trace_c_tag = root.find('trace_c')
        
        if(trace_c_tag):
            
            trace_c = trace_c_tag.findall('c')
            
            for f in trace_c:
                
                extra_files+= spaces + f.text.strip() + '\n'
                extra_files += '{spaces}{text}\n'.format(spaces = spaces,\
                                                         text = f.text.strip())

    elif(mode_str == 'autotune'):
        
        extra_files += \
        '''{spaces}fake_data_test/fake_data.cpp
{spaces}autotune.cpp'''.format(spaces = spaces)

    string = cmake_add_library_template.format(line_0 = line_0,\
                                               spaces = spaces,\
                                               extra_files = extra_files)

    return string

def include_directories(root, plasma_dir):
        
    #Obtain the include directories for PLASMA
    include_dirs = root.find('include_dirs').findall('dir')
        
    dir_list = ''

    string = ''

    line_0 = 'include_directories('

    spaces = (len(line_0) - 1) * ' '

    if(include_dirs != None):
        
        for d in include_dirs:
            
            dir_list += '{spaces}{text}\n'.format(spaces = spaces,\
                                                  text = d.text.strip())

        dir_list += '{spaces}{plasma_dir}/include'.format(spaces = spaces,\
                                                          plasma_dir = plasma_dir)
        
        string = cmake_include_dirs_template.format(line_0 = line_0,\
                                                    dir_list = dir_list,\
                                                    spaces = spaces)
        
    return string

def target_link_libraries(plasma_dir):
    
    line_0 = 'target_link_libraries('

    spaces = (len(line_0) - 1) * ' '

    string = cmake_target_link_libraries_template.format(line_0 = line_0,\
                                                         plasma_dir = plasma_dir,\
                                                         spaces = spaces)

    return string

def write_cmake_lists(cmake_lists, root, mode_str):
    
    plasma_dir = root.find('plasma_dir').text.strip()

    cpp_compiler = root.find('cpp_compiler').text.strip()

    c_compiler = root.find('c_compiler').text.strip()

    string = cmake_lists_template\
             .format(include_dirs = include_directories(root, plasma_dir),\
                     plasma_dir = plasma_dir,\
                     add_library = add_libraries(root, mode_str),\
                     c = c_compiler,\
                     cpp = cpp_compiler,
                     target_link_libraries = target_link_libraries(plasma_dir))

    cmake_lists.write(string)
    
    return

#Main code

#Create an argument parser
parser = argparse.ArgumentParser(description=\
            'Create an instance of the DARE runtime')

parser.add_argument('-c', '--config', \
                    help = 'Specify the XML config file', \
                    required = True)

tree = xml.parse(parser.parse_args().config)

root = tree.getroot()

#Determine operating mode
mode_tag = root.find('mode')

if(mode_tag != None):

    mode_str = mode_tag.text.strip()

else:

    print("No mode tag found. Exiting.")
    
    sys.exit()

#Create a regex object
rgx_obj = rgx_obj_class()

#Open files containing core_blas declarations
plasma_dir = root.find('plasma_dir').text.strip()

hdr_file_string = ''

p = Path(plasma_dir + '/include')

for f in p.iterdir():
    
    if(f.is_file() and rgx_obj.file_regex.fullmatch(f.name)):
        
        hdr_file_string += dump_file(str(f))

#Find the kernels with data dependencies and create a dictionary out of them
data_dep_functions = find_data_dep_functions(root)

#Create kernel map 
core_kernel_map = parse_hdr(hdr_file_string, mode_str, data_dep_functions)

core_kernel_list = core_kernel_map.values()

#Write autogen_types.h
autogen_types_h = open('autogen_types.h', 'w')

write_autogen_types_h(autogen_types_h, core_kernel_list)

autogen_types_h.close()

#write autogen.cpp
autogen_cpp = open('autogen.cpp', 'w')

write_autogen_cpp(autogen_cpp, core_kernel_list, root)

autogen_cpp.close()

#Autogenerate the hooks.cpp file
hooks_cpp = open('hooks.cpp', 'w')

write_hooks_cpp(hooks_cpp, core_kernel_list, root, mode_str, data_dep_functions)

hooks_cpp.close()

#Autogenerate the CMakeLists.txt file
cmake_lists = open('CMakeLists.txt', 'w')

write_cmake_lists(cmake_lists, root, mode_str)

cmake_lists.close()

subprocess.run(['cmake', '.'])

subprocess.run(['make'])
